# Lab3-实验报告

彭浩然 PB1901501055

## 编译方式

本次实验完全使用C++编写。由于使用了C++标准库中新加入的的线程库`<thread>`和协程库`<coruoutine>`，其要求的g++版本需在10以上，且打开支持协程的编译开关。

具体而言，开发使用的g++版本为：

```
gcc version 10.3.0 (Ubuntu 10.3.0-1ubuntu1~18.04~1)
```

一个编译指令示例如下：

```
g++ -g -std=c++20 /home/hurrypeng/chatroom/1.cpp -o /home/hurrypeng/chatroom/1.out -lpthread -fcoroutines
```

## `1.cpp`: 更加完善的双人聊天室

该程序将原本的`pthread`系列线程换成了C++11中加入的`<thread>`库中的`std::thread`系列线程，并作出了一些改进。

### 实现以换行为分隔符的消息分割

为在合适的地方加入`Message:`提示符分割消息，在每次`recv()`调用返回一批数据后，都会依次查找其中的每一个换行符，将换行符前的数据加入自定义的`SendBuffer`类的对象中，并使用`SendBuffer`的`send()`方法自动分批发送。如果收到的一批数据的末尾不是换行符，剩下的数据也会被缓存在`SendBuffer`中，等待下次`recv()`中最早的换行符。

### 处理可能的 `send()` 阻塞

`SendBuffer`类不仅能缓存一次性未接收完成的数据，还在发送方法`send()`中集成了自动切分消息、分批发送的功能。将消息切分发送可以有效解决一次性发送数据过多导致的`send()`阻塞问题。

## `2.cpp`: 多线程多人聊天室

为管理可能随时加入和退出的用户，现用一个`Client`结构体管理一个客户端相关的信息：是否连接、其文件描述符以及一个`std::mutex`互斥锁。

主线程循环等待新用户连接，当有新用户连接且连接数未满时，接受连接、修改一个空闲的`Client`结构体信息并为该用户创建一个线程。由于`Client`信息可能被多个进程查询，所以修改前，需先取得该`Client`的`std::mutex`的控制权。这是该互斥锁的第一个作用。

每个子线程负责分别负责接受一个客户端的信息，并转发给其他所有客户端。为了防止多个线程同时发送给一个客户端，每个客户端发送时需要先取得相应`Client`的`std::mutex`的控制权。这是该互斥锁的第二个作用。

## `3.cpp`：IO 复用多人聊天室

使用`fcntl()`将socket通信设为非阻塞式后，循环检查当前等待处理的IO请求（连接请求或消息请求），通过调用函数的方式，在一个线程内完成多个任务。

## `4.cpp`：协程多人聊天室

为实现协程多人聊天，需要先使用C++20的协程框架将非阻塞设定下的`recv()`和`accept()`函数封装为async函数`asyncRecv()`和`asyncAccept()`，并分别在负责接受客户连接的`handle_accept()`函数和负责处理消息的`handle_chat()`函数中调用。这两个函数也因此成为协程，不能直接被主函数调用，而需要一个外层的调度机制负责运行。在主函数中创建一个`handle_accept()`协程以及若干个对应不同客户端的`handle_chat()`协程，将其加入一个类似于“事件循环”（Event Loop）的结构中，轮流唤醒并处理，直到遇到`co_await`语句处理IO，此时协程会将控制流返还给主函数的“事件循环”，接着唤醒下一个先前挂起的协程。如是反复，就实现了一个结构上类似于多线程而却无需任何锁的协程多人聊天室。

